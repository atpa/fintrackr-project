const e="transaction-queue";function t(){return new Promise((t,n)=>{const r=indexedDB.open("fintrackr-offline",1);r.onerror=()=>n(r.error),r.onsuccess=()=>t(r.result),r.onupgradeneeded=t=>{const n=t.target.result;if(!n.objectStoreNames.contains(e)){const t=n.createObjectStore(e,{keyPath:"id",autoIncrement:!0});t.createIndex("timestamp","timestamp",{unique:!1}),t.createIndex("synced","synced",{unique:!1})}}})}async function n(n){try{const r=await t(),s=r.transaction([e],"readwrite").objectStore(e);return new Promise((e,t)=>{const r=s.get(n);r.onsuccess=()=>{const n=r.result;if(n){n.synced=!0,n.syncedAt=Date.now();const r=s.put(n);r.onsuccess=()=>{e()},r.onerror=()=>t(r.error)}else e()},r.onerror=()=>t(r.error)})}catch(r){throw r}}async function r(n){try{const r=await t(),s=r.transaction([e],"readwrite").objectStore(e);return new Promise((e,t)=>{const r=s.get(n);r.onsuccess=()=>{const n=r.result;if(n){n.retryCount=(n.retryCount||0)+1,n.lastRetry=Date.now();const r=s.put(n);r.onsuccess=()=>e(n.retryCount),r.onerror=()=>t(r.error)}else e(0)},r.onerror=()=>t(r.error)})}catch(r){return 0}}async function s(){try{const o=await async function(){try{const n=(await t()).transaction([e],"readonly").objectStore(e).index("synced");return new Promise((e,t)=>{const r=n.getAll(!1);r.onsuccess=()=>e(r.result),r.onerror=()=>t(r.error)})}catch(n){return[]}}();if(0===o.length)return{success:!0,synced:0,failed:0};let c=0,a=0;const i=3;for(const e of o)try{if(e.retryCount>=i){a++;continue}const{id:t,timestamp:s,synced:o,syncedAt:u,retryCount:d,lastRetry:y,...w}=e;(await fetch("/api/transactions",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(w)})).ok?(await n(t),c++):(await r(t),a++)}catch(s){await r(e.id),a++}return{success:!0,synced:c,failed:a}}catch(s){return{success:!1,error:s.message}}}function o(e,t="success"){window.toastSuccess&&"success"===t?window.toastSuccess(e):window.toastError&&"error"===t&&window.toastError(e)}"undefined"!=typeof window&&(window.addEventListener("online",async()=>{setTimeout(async()=>{const e=await s();e.synced>0&&o(`Синхронизировано транзакций: ${e.synced}`),e.failed>0&&o(`Не удалось синхронизировать: ${e.failed}`,"error")},2e3)}),"serviceWorker"in navigator&&navigator.serviceWorker.addEventListener("message",async e=>{e.data&&"SYNC_OFFLINE_QUEUE"===e.data.type&&await s()}));
